#### 反编译
* javap -c xxxx.class ls
    * 其中-c是反编译xxxx.class文件
    * 若要将反编译的数据放到文件可以
        * javap -c xxx.class | cat > xxx.txt 将内容覆盖到xxx.txt
        * javap -c xxx.class | tee xxx.txt 将输入写入文件xxx.txt
#### java代码中的结构映射到class文件中的结构
1. 对于实例
    ```
    public class Demo {
        private int a = 1;
        private final int b;
        // 构造函数1
        Demo() {}
        // 实例语句块1
        { b = 2; }
        // 构造函数2
        Demo(int a) {}
        // 实例语句块2
        { a = 0; }
    }
    ```
    * 定义实例变量的初值，实例语句块，实例构造函数<init>在字节码中的表现为：
        1. java代码中定义多少个构造函数字节码中就有几个实例构造函数，若没有定义也有一个默认的实例构造函数
        2. 每个字节码实例构造函数**都由**以下几部分**顺序排列**构成
            1. 调用父类的实例构造函数
            2. 实例变量定义的初值赋予（比如以上执行a = 1操作）与所有实例的语句块中代码按java代码中的自上而下执行
            4. 执行java代码中定义的实例构造函数内容
            * 意思是在每个字节码中的实例构造函数中，均被扩充了
2. 对于类
    * 凡是在类中定义有**类字段（不包括常量字段与静态内部类），静态块**，字节码中都会有类构造函数<clinit>
    * 定义类变量的初值，实例语句块，实例构造函数<init>在字节码中的表现为：
        * 类变量定义的初值赋予或**常量的非字面量赋值**(e.g. static final List l = new ArrayList()/null)
            与所有静态语句块中代码按java代码中的自上而下执行
3. 常量
    * 对于常量的直接字面量赋值，是直接在编译结束后就将其值放入字节码的常量池的
* 故在java代码运行的时候，**根据字节码先有按继承关系父子类初始化，然后才是按继承关系父子实例初始化**
    