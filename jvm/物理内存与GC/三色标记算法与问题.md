#### 并发标记中常用的三色标记算法
* 将对象分为三种
    1. 黑色：扫描完的根对象以及其子对象（即对象的成员变量）
    2. 灰色：扫描完对象，但其子对象未被扫描完
    3. 白色：未被扫描的对象，即完成所有扫描后的未被扫描的对象，这些对象就是不可达对象，即垃圾对象。 
* 扫描步骤
    1. 从gc roots开始扫描，初始roots是黑色，roots所引用的对象变为灰色
    2. 接下来从灰色对象开始向下扫描（只从灰色对象向下扫描）
    3. 扫描所由可达的对象，全部变为黑色对象
    4. 清理所由白的对象，即不可达对象
* 产生问题
    * 由于标记过程是并发标记的，gc线程标记的过程中，用户线程也在工作，过会产生标记出现漏标（没有标记那些存活的对象）
        或者误标（把垃圾对象标记成存活对象）的现象。
    * 漏标会收集那些存活的对象从而产生错误，而误标仅仅产生浮动垃圾
    * SATB（snapshot at the beginning, 用来解决漏标的问题）
        1. 在开始标记的时候生成一张快张图，标记此时刻存活的对象。
        2. 在并发标记的时候所有被改变的对象入队（在写屏障(write barrier)里吧所有旧的引用所指向的对象都变成非白色）
            * 对于移除灰对象中所引用的对象（白色），移除后将其标记为灰色对象。对于已经标记了的黑色对象锁新增的引用对象，
                将其标记为黑色。
        3. 可能存在浮动垃圾（由误标产生）将在下一次gc中收集
        * SATB是维持并发gc的一种个手段，g1并发的基础就是SATB
    