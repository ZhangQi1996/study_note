####简单概述
* ZooKeeper是一种为分布式应用所设计的高可用、高性能且一致的开源协调服务，它提供了一项基本服务：分布式锁服务。由于ZooKeeper的开源特性，后来我们的开发者在分布式锁的基础上，摸索了出了其他的使用方法：配置维护、组服务、分布式消息队列、分布式通知/协调等。
* 注意：ZooKeeper性能上的特点决定了它能够用在大型的、分布式的系统当中。从可靠性方面来说，它并不会因为一个节点的错误而崩溃。除此之外，它严格的序列访问控制意味着复杂的控制原语可以应用在客户端上。ZooKeeper在一致性、可用性、容错性的保证，也是ZooKeeper的成功之处，它获得的一切成功都与它采用的协议——Zab协议是密不可分的。

####数据模型（Znode）
* ZooKeeper的数据模型在结构上和标准文件系统的非常相似，都是采用这种树形层次结构，ZooKeeper树中的每个节点被称为Znode，同文件系统的目录树一样，ZooKeeper树中的每个节点都可以拥有子节点。
    1. 引用方式
    Zonde通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串"/zookeeper"用以保存管理信息，比如关键配额信息。
    2. Znode结构
        * ZooKeeper命名空间中的Znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。
        1. stat：此为状态信息, 描述Znode的版本, 权限等信息
        2. data：与Znode关联的数据
        3. children：Znode下的子节点
        * ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。ZooKeeper的服务器和客户端都被设计为严格检查并限制每个Znode的数据大小至多1M，但常规使用中应该远小于此值。
    3. 数据访问
        * ZooKeeper中的每个节点存储的数据要被原子性的操作。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。
    4. 节点类型
        * ZooKeeper中的节点有两种，分别为临时节点和永久节点。
        * 注意：节点的类型在创建时即被确定，并且不能改变。
            1. 临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节点不允许拥有子节点。
            2. 永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。
    5. 顺序节点
        * 当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个递增的计数。这个计数对于此节点的父节点来说是唯一的，它的格式为10位数字(没有数值的数位用0补充，例如"0000000001")。当计数值大于2的32次方-1时，计数器将溢出。
    6. 监视器
        * 客户端可以在节点上设置watch，我们称之为监视器。当节点状态发生改变时(Znode的增、删、改)将会触发watch所对应的操作。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次，这样可以减少网络流量。

####ZooKeeper中的时间
1. Zxid
    * 致使ZooKeeper节点状态改变的每一个操作都将使节点接收到一个Zxid格式的时间戳，并且这个时间戳全局有序。也就是说，每个对 节点的改变都将产生一个唯一的Zxid。如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。ZooKeeper的每个节点维护着三个Zxid值，为别为：cZxid、mZxid、pZxid。
    1. cZxid： 是节点的创建时间所对应的Zxid格式时间戳。
    2. mZxid：是节点的修改时间所对应的Zxid格式时间戳。
    3. pZxid：是该节点或子节点的最近一次创建/删除的zxid格式时间戳（不包括孙节点）
    * 注意：实现中Zxid是一个64为的数字，它高于32位时是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch。低于32位时是个递增计数。
2. 版本号
    * 对节点的每一个操作都将致使这个节点的版本号增加，每个节点维护着三个版本号。
    1. version：节点数据版本号
    2. cversion：子节点版本号
    3. aversion：节点所拥有的ACL版本号

####节点属性
* czxid:节点被创建的zxid
* mzxid:节点被修改的zxid
* ctime:节点被创建的时间
* mtime:节点被修改的时间
* version:节点被修改的版本号
* cversion:节点所拥有的子节点被修改的版本号
* aversion:节点的ACL被修改的版本号
* ephemeralOwner:如果此节点为临时节点，那么他的值为这个节点拥有者的会话ID；否则他的值为0
* dataLength:节点数长度
* numChildren:及诶单用的子节点长度
* pzxid:最新修改的zxid，效果和mzxid差不多
####服务中操作
* create:创建Znode（父Zonde必须存在）
* delete:删除Znode（Znode 没有子节点）
* exists:测试Znode是否存在，并获取他的元数据
* getACL/setACL:为Znode获取/设置 ACL
* getChildren:获取Znode所有子节点的列表
* getData/setData:获取/设置Znode的相关数据
* sync:使客户端的Znode视图与Zookeeper同步

####临时/持久节点
* 临时的节点ZNODE
    * ephemeralOwner=session_id
    * 面向会话的，仅存在与一个会话周期中，当会话周期结束就会将这个znode删除，临时znode没有子节点
    * 会由一个session 的过期时间，当cli断开连接的时候则session就会开始进入倒计时，当timeout(指的是意外中断)过去后，则这个znode
        就会被删除。
    * 若是客户端主动的close则临时节点会主动直接删除 
* 持久化节点
    * ephemeralOwner=0x0
* 注意以上两种节点都可以配有序列化
    * 也就是create -s
    * znode会带有一个编号不至于产生命名冲突