* 变量的定义
    * 与常见语言的定义方式一直
* 变量的引用与修改
    ```
    var=3 # 定义变量
    echo ${var} # 使用变量
    var=4 修改变量
  ```
  **注意=的左右两侧不能有空格**
  **注意字符串的定义可以不用加引号，但为了方便双引号内不含其他引用或者命令时，多用单引号，当含有其他引用或者命令时，则多用双引号**
* 单引号与双引号的区别
   ```
    url="http://c.biancheng.net"
    website1='C语言中文网：${url}'
    website2="C语言中文网：${url}"
    echo $website1
    echo $website2
    输出结果：
    C语言中文网：${url}
    C语言中文网：http://c.biancheng.net
    ```
    * 以单引号' '包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。
      
    *  以双引号" "包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。
      
    *  如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。
* 命令结果赋予变量
    ```
    方式1： var=`cmd`
    方式2： var=$(cmd) # 注意这里是小括号不是大括号
    e.g.
    var="hello `echo world`"
    ```
    * 原则上讲，上面提到的两种变量替换的形式是等价的，可以随意使用；但是，反引号毕竟看起来像单引号，有时候会对查看代码造成困扰，而使用 $() 就相对清晰，能有效避免这种混乱。而且有些情况必须使用 $()：$() 支持嵌套，反引号不行。
    * 要注意的是，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。所以这两种命令替换的方式各有特点，究竟选用哪种方式全看个人需求。
    ```
    # 故在含有多层嵌套的情况下用$()
    # 在不含多层潜逃的情况下用``
    ```
    * 注意如果被替换的命令的输出内容包括多行（也即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个。
    ```
    var="hello "`cat code.cpp`"" 
    echo "${var}"   # 在打印部分增加一个双引号即可，这样就会输出换行更多余的空白符了
    ```
* 将变量设置为只读变量
    ```
    var=1314 # 定义变量
    readonly var # 将变量设置为只读
    ``` 
* 删除变量（释放变量）
    ```
    var=1314
    unset var # 删除变量
    ```
* 变量的作用域
    * 局部变量
    ```
    # 注意在shell函数中定义的变量是全局变量
    function func() {
        var=3   # 注意这是全局变量
        local param=1314 # 在变量前加上local就是局部变量
    }
    ```
    * 全局变量
        * 在一个上下文环境中的变量
        * 作用范围是当前的shell进程
    * 环境变量
        * 在当前shell进程中定义的全局变量，然后通过export var来将其导出为一个全局变量
        * 注意该全局变量是在包含自己以及子孙进程中有效，全局变量传子不传父
* Shell位置参数（命令行参数）
    * 用$n来表示 e.g. $1表示命令行接受的第一个参数
    ```
    # 给脚本文件传递位置参数
    # 文件test.sh
    echo "第一个参数为$1"
    echo "第二个参数为$2"
    ---------------------------------
    调用：
    sh test.sh hello world
    ```
    * 注意在shell的函数定义时是不能带参数定义的，调用函数的时候可以传入参数，函数内通过$n来引用
    ```
    #定义函数
    function func(){
        echo "Language: $1"
        echo "URL: $2"
    }
    #调用函数
    func C++ http://c.biancheng.net/cplus/
    ```
    * 注意事项:如果参数个数太多，达到或者超过了 10 个，那么就得用${n}的形式来接收了，例如 ${10}、${23}。{ }的作用是为了帮助解释器识别参数的边界，这跟使用变量时加{ }是一样的效果。
* 特殊变量及其含义
    * $0	当前脚本的文件名。
    * $n（n≥1）	传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。
    * $#	传递给脚本或函数的参数个数。
    * $*	传递给脚本或函数的所有参数。
    * $@	传递给脚本或函数的所有参数。当被双引号" "包含时，$@ 与 $* 稍有不同
    ```
    # 对于$*与$@不被双引号包含时，二者都是返回传入的参数,但加了引号后,
    # 此时$*把参数作为一个字符串整体(单字符串)返回,$@把每个参数作为一个字符串返回
    例如 $*等价$@ '$*'等价'$@'
    而 "$*" => '1 2 3 4'   "$@" => '1' '2' '3' '4'
    即在 for i in "$*" 与 for i in "$@"可显著体现彼此区别 
    ```
    * $?	上个命令的退出状态，或函数的返回值
        * $? 获取上一个命令的退出状态
        * $? 获取函数的返回值
        ```
        #得到两个数相加的和
        function add(){
            return `expr $1 + $2`
        }
        add 23 50  #调用函数
        echo $?  #获取函数返回值
        -------------------------------------
        运行结果：
        73
        # 严格来说，Shell 函数中的 return 关键字用来表示函数的退出状态，而不是函数的返回值
        ```
    * $$	当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。
  